/*
 * MetaFab API
 *
 *  Complete MetaFab API references and guides can be found at: https://trymetafab.com
 *
 * The version of the OpenAPI document: 1.4.0
 * Contact: metafabproject@gmail.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`batch_mint_collection_items`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BatchMintCollectionItemsError {
    Status400(String),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`batch_transfer_collection_items`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BatchTransferCollectionItemsError {
    Status400(String),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`burn_collection_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BurnCollectionItemError {
    Status400(String),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCollectionError {
    Status400(String),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_collection_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCollectionItemError {
    Status400(String),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_collection_approval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCollectionApprovalError {
    Status400(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_collection_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCollectionItemError {
    Status400(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_collection_item_balance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCollectionItemBalanceError {
    Status400(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_collection_item_balances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCollectionItemBalancesError {
    Status400(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_collection_item_supplies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCollectionItemSuppliesError {
    Status400(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_collection_item_supply`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCollectionItemSupplyError {
    Status400(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_collection_item_timelock`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCollectionItemTimelockError {
    Status400(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_collection_items`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCollectionItemsError {
    Status400(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_collection_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCollectionRoleError {
    Status400(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_collections`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCollectionsError {
    Status400(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`grant_collection_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GrantCollectionRoleError {
    Status400(String),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mint_collection_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MintCollectionItemError {
    Status400(String),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_collection_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeCollectionRoleError {
    Status400(String),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_collection_approval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetCollectionApprovalError {
    Status400(String),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_collection_item_timelock`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetCollectionItemTimelockError {
    Status400(String),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`transfer_collection_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransferCollectionItemError {
    Status400(String),
    Status401(String),
    UnknownValue(serde_json::Value),
}


/// Creates (mints) the provided itemIds of the specified quantities to the provided wallet address or wallet address associated with the provided walletId.
pub async fn batch_mint_collection_items(configuration: &configuration::Configuration, collection_id: &str, x_authorization: &str, x_password: &str, batch_mint_collection_items_request: crate::models::BatchMintCollectionItemsRequest) -> Result<crate::models::TransactionModel, Error<BatchMintCollectionItemsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/batchMints", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-Authorization", x_authorization.to_string());
    local_var_req_builder = local_var_req_builder.header("X-Password", x_password.to_string());
    local_var_req_builder = local_var_req_builder.json(&batch_mint_collection_items_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BatchMintCollectionItemsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Transfers one or multiple items of specified quantities to the provided wallet addresses or wallet addresses associated with the provided walletIds. You may also provide a combination of addresses and walletIds in one request.
pub async fn batch_transfer_collection_items(configuration: &configuration::Configuration, collection_id: &str, x_authorization: &str, x_password: &str, batch_transfer_collection_items_request: crate::models::BatchTransferCollectionItemsRequest) -> Result<crate::models::TransactionModel, Error<BatchTransferCollectionItemsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/batchTransfers", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-Authorization", x_authorization.to_string());
    local_var_req_builder = local_var_req_builder.header("X-Password", x_password.to_string());
    local_var_req_builder = local_var_req_builder.json(&batch_transfer_collection_items_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BatchTransferCollectionItemsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes (burns) the provided quantity of the collectionItemId from the authenticating game or players wallet. The quantity is permanently removed from the circulating supply of the item.
pub async fn burn_collection_item(configuration: &configuration::Configuration, collection_id: &str, collection_item_id: f32, x_authorization: &str, x_password: &str, burn_collection_item_request: crate::models::BurnCollectionItemRequest) -> Result<crate::models::TransactionModel, Error<BurnCollectionItemError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/items/{collectionItemId}/burns", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id), collectionItemId=collection_item_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-Authorization", x_authorization.to_string());
    local_var_req_builder = local_var_req_builder.header("X-Password", x_password.to_string());
    local_var_req_builder = local_var_req_builder.json(&burn_collection_item_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BurnCollectionItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a new game item collection and deploys an extended functionality ERC1155 contract on behalf of the authenticating game's primary wallet. The deployed ERC1155 contract is preconfigured to fully support creating unique item types, item transfer timelocks, custom metadata per item, gasless transactions from player managed wallets, and much more.
pub async fn create_collection(configuration: &configuration::Configuration, x_authorization: &str, x_password: &str, create_collection_request: crate::models::CreateCollectionRequest) -> Result<crate::models::CreateCollection200Response, Error<CreateCollectionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-Authorization", x_authorization.to_string());
    local_var_req_builder = local_var_req_builder.header("X-Password", x_password.to_string());
    local_var_req_builder = local_var_req_builder.json(&create_collection_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateCollectionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a new item type. Item type creation associates all of the relevant item data to a specific itemId. Such as item name, image, description, attributes, any arbitrary data such as 2D or 3D model resolver URLs, and more. It is recommended, but not required, that you create a new item type through this endpoint before minting any quantity of the related itemId.  Any itemId provided will have its existing item type overriden if it already exists.  Item type data is uploaded to, and resolved through IPFS for decentralized persistence.
pub async fn create_collection_item(configuration: &configuration::Configuration, collection_id: &str, x_authorization: &str, x_password: &str, create_collection_item_request: crate::models::CreateCollectionItemRequest) -> Result<crate::models::TransactionModel, Error<CreateCollectionItemError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/items", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-Authorization", x_authorization.to_string());
    local_var_req_builder = local_var_req_builder.header("X-Password", x_password.to_string());
    local_var_req_builder = local_var_req_builder.json(&create_collection_item_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateCollectionItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a boolean (true/false) representing if the provided operatorAddress has approval to transfer and burn items from the current collection owned by the address or address associated with the provided walletId.
pub async fn get_collection_approval(configuration: &configuration::Configuration, collection_id: &str, operator_address: &str, address: Option<&str>, wallet_id: Option<&str>) -> Result<bool, Error<GetCollectionApprovalError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/approvals", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("operatorAddress", &operator_address.to_string())]);
    if let Some(ref local_var_str) = address {
        local_var_req_builder = local_var_req_builder.query(&[("address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = wallet_id {
        local_var_req_builder = local_var_req_builder.query(&[("walletId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCollectionApprovalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a metadata object for the provided collectionItemId.
pub async fn get_collection_item(configuration: &configuration::Configuration, collection_id: &str, collection_item_id: f32) -> Result<serde_json::Value, Error<GetCollectionItemError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/items/{collectionItemId}", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id), collectionItemId=collection_item_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCollectionItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the current collection item balance of the provided collectionItemId for the provided wallet address or the wallet address associated with the provided walletId.
pub async fn get_collection_item_balance(configuration: &configuration::Configuration, collection_id: &str, collection_item_id: f32, address: Option<&str>, wallet_id: Option<&str>) -> Result<i32, Error<GetCollectionItemBalanceError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/items/{collectionItemId}/balances", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id), collectionItemId=collection_item_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = address {
        local_var_req_builder = local_var_req_builder.query(&[("address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = wallet_id {
        local_var_req_builder = local_var_req_builder.query(&[("walletId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCollectionItemBalanceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the current collection item balances of all collection items for the provided wallet address or the wallet address associated with the provided walletId.
pub async fn get_collection_item_balances(configuration: &configuration::Configuration, collection_id: &str, address: Option<&str>, wallet_id: Option<&str>) -> Result<::std::collections::HashMap<String, i32>, Error<GetCollectionItemBalancesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/balances", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = address {
        local_var_req_builder = local_var_req_builder.query(&[("address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = wallet_id {
        local_var_req_builder = local_var_req_builder.query(&[("walletId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCollectionItemBalancesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the currency circulating supply of all collection items.
pub async fn get_collection_item_supplies(configuration: &configuration::Configuration, collection_id: &str) -> Result<::std::collections::HashMap<String, i32>, Error<GetCollectionItemSuppliesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/supplies", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCollectionItemSuppliesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the current circulating supply of the provided collectionItemId.
pub async fn get_collection_item_supply(configuration: &configuration::Configuration, collection_id: &str, collection_item_id: f32, address: Option<&str>, wallet_id: Option<&str>) -> Result<i32, Error<GetCollectionItemSupplyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/items/{collectionItemId}/supplies", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id), collectionItemId=collection_item_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = address {
        local_var_req_builder = local_var_req_builder.query(&[("address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = wallet_id {
        local_var_req_builder = local_var_req_builder.query(&[("walletId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCollectionItemSupplyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a timestamp (in seconds) for when the provided collectionItemId's transfer timelock expires. A value of 0 means the provided collectionItemId does not have a timelock set. Timelocks prevent items of a specific collectionItemId from being transferred until the set timelock timestamp has been surpassed.
pub async fn get_collection_item_timelock(configuration: &configuration::Configuration, collection_id: &str, collection_item_id: f32) -> Result<i32, Error<GetCollectionItemTimelockError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/items/{collectionItemId}/timelocks", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id), collectionItemId=collection_item_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCollectionItemTimelockError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all collection items as an array of metadata objects.
pub async fn get_collection_items(configuration: &configuration::Configuration, collection_id: &str) -> Result<Vec<serde_json::Value>, Error<GetCollectionItemsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/items", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCollectionItemsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a boolean (true/false) representing if the provided role for this collection has been granted to the provided address or address associated with the provided walletId.
pub async fn get_collection_role(configuration: &configuration::Configuration, collection_id: &str, role: &str, address: Option<&str>, wallet_id: Option<&str>) -> Result<bool, Error<GetCollectionRoleError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/roles", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("role", &role.to_string())]);
    if let Some(ref local_var_str) = address {
        local_var_req_builder = local_var_req_builder.query(&[("address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = wallet_id {
        local_var_req_builder = local_var_req_builder.query(&[("walletId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCollectionRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns an array of active item collections for the game associated with the provided `X-Game-Key`.
pub async fn get_collections(configuration: &configuration::Configuration, x_game_key: &str) -> Result<Vec<crate::models::GetCollections200ResponseInner>, Error<GetCollectionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-Game-Key", x_game_key.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCollectionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Grants the provided role for the collection to the provided address or address associated with the provided walletId. Granted roles give different types of authority on behalf of the collection for specific players, addresses, or contracts to perform different types of permissioned collection operations.
pub async fn grant_collection_role(configuration: &configuration::Configuration, collection_id: &str, x_authorization: &str, x_password: &str, grant_collection_role_request: crate::models::GrantCollectionRoleRequest) -> Result<crate::models::TransactionModel, Error<GrantCollectionRoleError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/roles", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-Authorization", x_authorization.to_string());
    local_var_req_builder = local_var_req_builder.header("X-Password", x_password.to_string());
    local_var_req_builder = local_var_req_builder.json(&grant_collection_role_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GrantCollectionRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates (mints) the specified quantity of the provided collectionItemId to the provided wallet address or wallet address associated with the provided walletId.
pub async fn mint_collection_item(configuration: &configuration::Configuration, collection_id: &str, collection_item_id: f32, x_authorization: &str, x_password: &str, mint_collection_item_request: crate::models::MintCollectionItemRequest) -> Result<crate::models::TransactionModel, Error<MintCollectionItemError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/items/{collectionItemId}/mints", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id), collectionItemId=collection_item_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-Authorization", x_authorization.to_string());
    local_var_req_builder = local_var_req_builder.header("X-Password", x_password.to_string());
    local_var_req_builder = local_var_req_builder.json(&mint_collection_item_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MintCollectionItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Revokes the provided role for the collection to the provided address or address associated with the provided walletId.
pub async fn revoke_collection_role(configuration: &configuration::Configuration, collection_id: &str, x_authorization: &str, x_password: &str, revoke_collection_role_request: crate::models::RevokeCollectionRoleRequest) -> Result<crate::models::TransactionModel, Error<RevokeCollectionRoleError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/roles", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-Authorization", x_authorization.to_string());
    local_var_req_builder = local_var_req_builder.header("X-Password", x_password.to_string());
    local_var_req_builder = local_var_req_builder.json(&revoke_collection_role_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RevokeCollectionRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sets approval for the provided address or wallet address associated with the provided walletId to operate on behalf of the authenticating game or player's owned items for this collection. Setting an approved value of `true` allows the provided address or address associated with the provided walletId to transfer and burn items from this collection on behalf of the authenticated game or player's wallet address.
pub async fn set_collection_approval(configuration: &configuration::Configuration, collection_id: &str, x_authorization: &str, x_password: &str, set_collection_approval_request: crate::models::SetCollectionApprovalRequest) -> Result<crate::models::TransactionModel, Error<SetCollectionApprovalError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/approvals", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-Authorization", x_authorization.to_string());
    local_var_req_builder = local_var_req_builder.header("X-Password", x_password.to_string());
    local_var_req_builder = local_var_req_builder.json(&set_collection_approval_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetCollectionApprovalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sets the item timelock for the provided collection itemId. The timelock is a unix timestamp (in seconds) that defines a period in time of when an item may be transferred by players. Until the timelock timestamp has passed, the itemId for the given timelock may not be transferred, sold, traded, etc. A timelock of 0 (default) means that there is no timelock set on the itemId and it can be freely transferred, traded, etc.
pub async fn set_collection_item_timelock(configuration: &configuration::Configuration, collection_id: &str, collection_item_id: f32, x_authorization: &str, x_password: &str, set_collection_item_timelock_request: crate::models::SetCollectionItemTimelockRequest) -> Result<crate::models::TransactionModel, Error<SetCollectionItemTimelockError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/items/{collectionItemId}/timelocks", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id), collectionItemId=collection_item_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-Authorization", x_authorization.to_string());
    local_var_req_builder = local_var_req_builder.header("X-Password", x_password.to_string());
    local_var_req_builder = local_var_req_builder.json(&set_collection_item_timelock_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetCollectionItemTimelockError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Transfers specified quantity of itemId to the provided wallet address or wallet address associated with the provided walletId.
pub async fn transfer_collection_item(configuration: &configuration::Configuration, collection_id: &str, collection_item_id: f32, x_authorization: &str, x_password: &str, transfer_collection_item_request: crate::models::TransferCollectionItemRequest) -> Result<crate::models::TransactionModel, Error<TransferCollectionItemError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/collections/{collectionId}/items/{collectionItemId}/transfers", local_var_configuration.base_path, collectionId=crate::apis::urlencode(collection_id), collectionItemId=collection_item_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-Authorization", x_authorization.to_string());
    local_var_req_builder = local_var_req_builder.header("X-Password", x_password.to_string());
    local_var_req_builder = local_var_req_builder.json(&transfer_collection_item_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TransferCollectionItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

